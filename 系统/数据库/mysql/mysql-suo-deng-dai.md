innodb 储存引擎是通过给索引上的索引项加锁来实现的，这就意味着：只有通过索引条件检索的数据，innodb 才会使用行级锁，否则，innodb 会给整张表的所有数据行的加锁。

##### 行锁演示：

![](/assets/screenshot_2018_03_22T14_42_36+0759.png)

在并发访问比较高的情况下，如果大量事务因无法立即获得所需的锁而挂起，会占用大量计算机资源，造成严重的性能问题，甚至拖垮数据库，这时需要通过设置适合的**锁等待超时**阀值参数 innodb\_lock\_wait\_timeout 来解决，一般设置为 100 秒即可。

> innodb\_rollback\_on\_timeout  
> on:  
> 事务内多条语句，当一条语句遇到锁等待超时  
>     这条语句及这条语句之前的语句，将会回滚  
>     这条语句之后的语句，将胡会由事务提交，是直接修改  
> off:  
> 事务内多条语句，当一条语句遇到锁等待超时  
>     仅仅这条锁等待的语句无法提交，其他语句将可以被提交

##### 表锁演示：

![](/assets/screenshot_2018_03_22T14_49_55+0759.png)

从上面演示的内容可以看出，只有使用索引条件检索数据，innodb 才会使用行级锁，否则，innodb 将使用表锁。需要通过设置适合的**锁等待超时**阀值参数 innodb\_lock\_wait\_timeout 来解决，一般设置为 100 秒即可。

##### 表锁解锁：

1. kill 掉语句线程 id
2. kill 掉连接线程 id
3. 重启服务

##### 死锁演示：

两个事务都需要获得对方持有的排他锁才能继续完成事务，这种循环锁等待就是典型的死锁。

![](/assets/screenshot_2018_03_22T14_56_15+0759.png)

发生死锁后，innodb 一般都能自动检测到，它会让一个事务释放锁并回退，另一个事务则获得锁，继续完成事务。死锁是无法避免的，我们可以通过调整业务的逻辑来尽量减少死锁出现的概率。

> innodb\_print\_all\_deadlocks = on，可以将死锁信息输出到错误日志中

##### 死锁检测：

##### 避免死锁：

* 在代码层调整SQL操作顺序，或者缩短事务长度，以避免出现死锁。
* 对应用程序进行调整/修改。在某些情况下，你可以通过把大事务分解成多个小事务，使得锁能够更快被释放，从而极大程度地降低死锁发生的频率。在其他情况下，死锁的发生是因为两个事务采用不同的顺序操作了一个或多个表的相同的数据集。需要改成以相同顺序读写这些数据集，换言之，就是对这些数据集的访问采用串行化方式。这样在并发事务时，就让死锁变成了锁等待。
* 修改表的schema，例如删除外键约束来分离两张表，或者添加索引来减少扫描和锁定的行。
* 如果发生了间隙锁，你可以把会话或者事务的事务隔离级别更改为RC\(read committed\)级别来避免，可以避免掉很多因为gap锁造成的死锁，但此时需要把binlog\_format设置成row或者mixed格式。
* 为表添加合理的索引，不走索引将会为表的每一行记录添加上锁，死锁的概率大大增大。

> ```
> 《MySQL 管理之道：性能调优、高可用与监控（第2版）》 - 5.3.2 行锁演示
> MySQL InnoDB死锁及死锁检测（四） 运维那点事 - http://www.ywnds.com/?p=4949
> ```



